snippet main
	#include <glib.h>

	gint
	main (gint   argc,
	      gchar *argv[])
	{
		g_set_prgname ("${1:my-program}");
		g_set_application_name ("${2:$1|capitalize}");

		$0

		return 0;
	}
snippet fail
	g_return_if_fail (${1});$0
snippet vfail
	g_return_val_if_fail (${1}, ${2:NULL});$0
snippet gpl
	/* ${1:$filename}
	 *
	 * Copyright (C) $year ${2:$fullname} <${3:$email}>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	$0
snippet lgpl
	/* ${1:$filename}
	 *
	 * Copyright (C) $year ${2:$fullname} <${3:$email}>
	 *
	 * This file is free software; you can redistribute it and/or modify it
	 * under the terms of the GNU Lesser General Public License as
	 * published by the Free Software Foundation; either version 3 of the
	 * License, or (at your option) any later version.
	 *
	 * This file is distributed in the hope that it will be useful, but
	 * WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 * Lesser General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	$0
snippet W
	GtkWidget *
snippet gp
	gpointer 
snippet gb
	gboolean 
snippet for
	for (${1:i = 0}; ${2:i < }; ${3:i++})
	  {
	    $0
	  }
snippet inc
	#include "${1}"$0
snippet Inc
	#include <${1}>$0
snippet hobject
	#ifndef ${$1|functify|upper}_H
	#define ${$1|functify|upper}_H

	#include <${3:glib-object.h}>

	G_BEGIN_DECLS

	#define ${$1|functify|namespace|upper}_TYPE_${$1|class|functify|upper}            (${$1|functify}_get_type())
	#define ${$1|functify|namespace|upper}_${$1|class|functify|upper}(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), ${$1|functify|namespace|upper}_TYPE_${$1|class|functify|upper}, $1))
	#define ${$1|functify|namespace|upper}_${$1|class|functify|upper}_CONST(obj)      (G_TYPE_CHECK_INSTANCE_CAST ((obj), ${$1|functify|namespace|upper}_TYPE_${$1|class|functify|upper}, $1 const))
	#define ${$1|functify|namespace|upper}_${$1|class|functify|upper}_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  ${$1|functify|namespace|upper}_TYPE_${$1|class|functify|upper}, $1Class))
	#define ${$1|functify|namespace|upper}_IS_${$1|class|functify|upper}(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ${$1|functify|namespace|upper}_TYPE_${$1|class|functify|upper}))
	#define ${$1|functify|namespace|upper}_IS_${$1|class|functify|upper}_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  ${$1|functify|namespace|upper}_TYPE_${$1|class|functify|upper}))
	#define ${$1|functify|namespace|upper}_${$1|class|functify|upper}_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  ${$1|functify|namespace|upper}_TYPE_${$1|class|functify|upper}, $1Class))

	typedef struct _$1        $1;
	typedef struct _$1Class   $1Class;
	typedef struct _$1Private $1Private;

	struct _${1:MyObject}
	{
		${2:GObject} parent;

		/*< private >*/
		$1Private *priv;
	};

	struct _$1Class
	{
		$2Class parent;
	};

	GType ${$1|functify}_get_type (void) G_GNUC_CONST;
	$1 *${$1|functify}_new (void);
	$0
	G_END_DECLS

	#endif /* ${$1|functify|upper}_H */
snippet cobject
	#include "${1}.h"

	struct _${2:$1|camelize}Private
	{
		$0
	};

	G_DEFINE_TYPE_WITH_PRIVATE ($2, ${3:$1|functify}, ${4:G_TYPE_OBJECT})

	enum {
		PROP_0,
		LAST_PROP
	};

	static GParamSpec *gParamSpecs [LAST_PROP];

	$2 *
	$3_new (void)
	{
		return g_object_new (${$1|namespace|functify|upper}_TYPE_${$1|class|functify|upper}, NULL);
	}

	static void
	$3_finalize (GObject *object)
	{
		$2Private *priv = ${$3|upper} (object)->priv;

		G_OBJECT_CLASS ($3_parent_class)->finalize (object);
	}

	static void
	$3_get_property (GObject    *object,
	${$3|space}               guint       prop_id,
	${$3|space}               GValue     *value,
	${$3|space}               GParamSpec *pspec)
	{
		$2 *self = ${$3|upper} (object);

		switch (prop_id)
		  {
		  default:
		    G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
		  }
	}

	static void
	$3_set_property (GObject      *object,
	${$3|space}               guint         prop_id,
	${$3|space}               const GValue *value,
	${$3|space}               GParamSpec   *pspec)
	{
		$2 *self = ${$3|upper} (object);

		switch (prop_id)
		  {
		  default:
		    G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
		  }
	}

	static void
	$3_class_init ($2Class *klass)
	{
		GObjectClass *object_class = G_OBJECT_CLASS (klass);

		object_class->finalize = $3_finalize;
		object_class->get_property = $3_get_property;
		object_class->set_property = $3_set_property;
	}

	static void
	$3_init ($2 *self)
	{
		self->priv = $3_get_instance_private (self);
	}
snippet pr
	${1:MyObject}Private *priv;$0
